use crate::commands::net::ping::ping_concurrent_async;
use crate::commands::pentest::fingerprint::load_fingerprints;
use crate::commands::pentest::port_list::*;
use crate::utils::{ScanProgress, parse_ports, parse_targets, save_to_excel};
use clap::Parser;
use futures::stream::{FuturesUnordered, StreamExt};
use std::error::Error;
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::net::TcpStream;
use tokio::sync::{Mutex, Semaphore};

/// ç«¯å£æ‰«æå‚æ•°é…ç½®
#[derive(Parser, Debug)]
pub struct PortScanArgs {
    /// ç›®æ ‡IPæˆ–IPæ®µï¼ˆæ”¯æŒCIDRã€èŒƒå›´ã€å¤šä¸ªIPç”¨é€—å·éš”å¼€ï¼‰
    ///
    /// ç¤ºä¾‹ï¼š
    /// - å•ä¸ªIP: 192.168.1.1
    /// - å¤šä¸ªIP: 192.168.1.1,192.168.1.2
    /// - IPèŒƒå›´: 192.168.1.1-10
    /// - CIDR: 192.168.1.0/24
    #[arg(short, long, value_name = "TARGET")]
    pub targets: String,

    /// è‡ªå®šä¹‰ç«¯å£åˆ—è¡¨ï¼ˆç”¨é€—å·éš”å¼€ï¼Œæ”¯æŒèŒƒå›´ï¼‰
    ///
    /// ç¤ºä¾‹ï¼š22,80,443,8000-9000
    #[arg(short, long, value_name = "PORTS")]
    pub ports: Option<String>,

    /// æ‰«æå…¨éƒ¨ç«¯å£ï¼ˆ1-65535ï¼‰
    #[arg(long)]
    pub full: bool,

    /// æœ€å¤§å¹¶å‘æ•°
    #[arg(short = 'c', long, default_value = "200", value_name = "NUM")]
    pub concurrency: usize,

    /// æ˜¯å¦è¾“å‡ºç»“æœåˆ°Excelæ–‡ä»¶
    #[arg(short = 'o', long)]
    pub output: bool,

    /// å…ˆè¿›è¡Œä¸»æœºå­˜æ´»æ¢æµ‹ï¼ˆPingæ‰«æï¼‰
    #[arg(long)]
    pub live: bool,
}

/// ç«¯å£æ‰«æç»“æœ
#[derive(Debug, Clone)]
pub struct PortScanResult {
    /// IPåœ°å€
    pub ip: String,
    /// ç«¯å£å·
    pub port: u16,
    /// çŠ¶æ€ï¼ˆå¼€æ”¾/å…³é—­ï¼‰
    pub status: String,
    /// æœåŠ¡bannerä¿¡æ¯
    pub banner: String,
    /// è¯†åˆ«è¯æ®åˆ—è¡¨
    pub evidence: Vec<String>,
}

impl PortScanResult {
    /// åˆ›å»ºå¼€æ”¾ç«¯å£çš„ç»“æœ
    fn open(ip: String, port: u16, banner: String, evidence: Vec<String>) -> Self {
        Self {
            ip,
            port,
            status: "å¼€æ”¾".to_string(),
            banner,
            evidence,
        }
    }

    /// åˆ›å»ºå…³é—­ç«¯å£çš„ç»“æœ
    fn closed(ip: String, port: u16) -> Self {
        Self {
            ip,
            port,
            status: "å…³é—­".to_string(),
            banner: String::new(),
            evidence: Vec::new(),
        }
    }

    /// æ£€æŸ¥ç«¯å£æ˜¯å¦å¼€æ”¾
    pub fn is_open(&self) -> bool {
        self.status == "å¼€æ”¾"
    }
}

pub async fn run(args: &PortScanArgs) -> Result<(), Box<dyn Error + Send + Sync>> {
    let start = Instant::now();

    // åŠ è½½æŒ‡çº¹åº“
    let fps = load_fingerprints("fingerprints.yaml")?;

    // è§£æç›®æ ‡IPåˆ—è¡¨
    let ips = parse_targets(&args.targets)?;

    // å¦‚æœå¯ç”¨äº†å­˜æ´»æ¢æµ‹ï¼Œå…ˆè¿›è¡ŒPingæ‰«æ
    let live_ips = if args.live {
        println!("ğŸ” å¼€å§‹ä¸»æœºå­˜æ´»æ¢æµ‹...");
        let ping_progress = ScanProgress::new(ips.len() as u64);
        let ping_results = ping_concurrent_async(ips.clone(), 3, 2, 100, &ping_progress).await?;

        let alive: Vec<String> = ping_results
            .into_iter()
            .filter(|r| r.is_success())
            .map(|r| r.ip)
            .collect();

        println!("âœ… å‘ç° {} ä¸ªå­˜æ´»ä¸»æœº", alive.len());
        alive
    } else {
        ips
    };

    if live_ips.is_empty() {
        return Err("æ²¡æœ‰æœ‰æ•ˆçš„IPåœ°å€å¯ä¾›æ‰«æ".into());
    }

    // ç¡®å®šè¦æ‰«æçš„ç«¯å£åˆ—è¡¨
    let ports: Vec<u16> = if args.full {
        println!("âš ï¸  å…¨ç«¯å£æ‰«ææ¨¡å¼ï¼ˆ1-65535ï¼‰");
        (1..=65535).collect()
    } else if let Some(ref port_str) = args.ports {
        let parsed = parse_ports(port_str);
        if parsed.is_empty() {
            return Err("æœªè§£æåˆ°ä»»ä½•æœ‰æ•ˆç«¯å£".into());
        }
        parsed
    } else {
        DEFAULT_PORTS.to_vec()
    };

    let total_tasks = (live_ips.len() * ports.len()) as u64;
    println!(
        "ğŸ” å¼€å§‹ç«¯å£æ‰«æ: {} ä¸ªIP Ã— {} ä¸ªç«¯å£ = {} ä¸ªä»»åŠ¡",
        live_ips.len(),
        ports.len(),
        total_tasks
    );
    println!("âš™ï¸  é…ç½®: å¹¶å‘={}", args.concurrency);

    // åˆå§‹åŒ–ç»“æœå­˜å‚¨å’Œè¿›åº¦æ¡
    let results = Arc::new(Mutex::new(Vec::<PortScanResult>::with_capacity(
        total_tasks as usize,
    )));
    let progress = ScanProgress::new(total_tasks);

    // å¹¶å‘æ§åˆ¶ä¿¡å·é‡
    let sem = Arc::new(Semaphore::new(args.concurrency));
    let mut tasks = FuturesUnordered::new();

    // ä¸ºæ¯ä¸ªIPå’Œç«¯å£åˆ›å»ºæ‰«æä»»åŠ¡
    for ip in live_ips {
        for &port in &ports {
            let permit = sem.clone().acquire_owned().await?;
            let ip_cloned = ip.clone();
            let results_clone = results.clone();
            let progress_clone = progress.clone();
            let fps_clone = fps.clone();

            tasks.push(tokio::spawn(async move {
                let _permit = permit;

                // æ‰«æå•ä¸ªç«¯å£
                let result = scan_single_port(&ip_cloned, port, &fps_clone, &progress_clone).await;

                // ä¿å­˜ç»“æœ
                {
                    let mut results_guard = results_clone.lock().await;
                    results_guard.push(result);
                }

                progress_clone.inc(1);
            }));
        }
    }

    // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    while tasks.next().await.is_some() {}

    progress.finish_with_message("âœ… ç«¯å£æ‰«æå®Œæˆ");

    // è·å–æœ€ç»ˆç»“æœ
    let final_results = Arc::try_unwrap(results)
        .expect("æ— æ³•è·å–æœ€ç»ˆç»“æœ")
        .into_inner();

    // ç»Ÿè®¡ç»“æœ
    let open_ports: Vec<&PortScanResult> = final_results.iter().filter(|r| r.is_open()).collect();

    let total_scanned = final_results.len();
    let open_count = open_ports.len();
    let closed_count = total_scanned - open_count;

    // ä¿å­˜åˆ°Excel
    if args.output {
        save_to_excel(
            &final_results,
            &["IPåœ°å€", "ç«¯å£", "çŠ¶æ€", "æœåŠ¡", "è¯æ®"],
            |r| {
                vec![
                    r.ip.clone(),
                    r.port.to_string(),
                    r.status.clone(),
                    r.banner.clone(),
                    r.evidence.join("; "),
                ]
            },
            "portscan",
            "portscan",
        )?;
    }

    // æ‰“å°æ€»ç»“
    let elapsed = start.elapsed();
    println!("\nğŸ“Š æ‰«æç»Ÿè®¡:");
    println!("   æ€»è®¡: {} ä¸ªç«¯å£", total_scanned);
    println!(
        "   å¼€æ”¾: {} ä¸ª ({:.1}%)",
        open_count,
        (open_count as f64 / total_scanned as f64) * 100.0
    );
    println!(
        "   å…³é—­: {} ä¸ª ({:.1}%)",
        closed_count,
        (closed_count as f64 / total_scanned as f64) * 100.0
    );
    println!("   è€—æ—¶: {:.2?}", elapsed);

    // æŒ‰IPåˆ†ç»„æ˜¾ç¤ºå¼€æ”¾ç«¯å£
    if open_count > 0 {
        println!("\nğŸ”“ å¼€æ”¾ç«¯å£è¯¦æƒ…:");
        let mut grouped: std::collections::HashMap<String, Vec<&PortScanResult>> =
            std::collections::HashMap::new();
        for result in &open_ports {
            grouped.entry(result.ip.clone()).or_default().push(result);
        }

        for (ip, ports) in grouped.iter() {
            let port_list: Vec<String> = ports.iter().map(|p| p.port.to_string()).collect();
            println!("   {} => [{}]", ip, port_list.join(", "));
        }
    }

    Ok(())
}

/// æ‰«æå•ä¸ªç«¯å£
///
/// # å‚æ•°
/// * `ip` - IPåœ°å€
/// * `port` - ç«¯å£å·
/// * `fps` - æŒ‡çº¹åº“
/// * `progress` - è¿›åº¦æ¡ï¼ˆç”¨äºè¾“å‡ºä¿¡æ¯ï¼‰
///
/// # è¿”å›
/// * `PortScanResult` - æ‰«æç»“æœ
async fn scan_single_port(
    ip: &str,
    port: u16,
    _fps: &[crate::commands::pentest::fingerprint::Fingerprint],
    progress: &ScanProgress,
) -> PortScanResult {
    let addr = format!("{}:{}", ip, port);
    let mut evidence: Vec<String> = Vec::new();
    let mut banner = String::new();

    // å°è¯•è¿æ¥å¹¶è¯»å–banner
    if let Some(buf) = connect_and_read(
        &addr,
        Duration::from_secs(3),
        Duration::from_secs(2),
        Duration::from_millis(400),
        4096,
    )
    .await
    {
        // è¯†åˆ«åè®®å’ŒæœåŠ¡
        if buf.starts_with(b"SSH-") {
            if let Ok(s) = std::str::from_utf8(&buf) {
                banner = s.lines().next().unwrap_or("SSH").to_string();
                evidence.push("ssh-banner".to_string());
            }
        } else if is_mysql_handshake(&buf) {
            banner = extract_mysql_banner(&buf);
            evidence.push(format!("mysql-handshake (len={})", buf.len()));
        } else if is_rdp_response(&buf) {
            banner = extract_rdp_banner(&buf);
            evidence.push("rdp-response".to_string());
        } else {
            banner = extract_banner_text(&buf);
            evidence.push("initial-raw".to_string());
        }

        // ç”Ÿæˆç»“æœ - ç«¯å£å¼€æ”¾
        if banner.trim().is_empty() {
            banner = "æœåŠ¡æœªçŸ¥".to_string();
        }
        progress.println(format!(
            "  âœ… {}:{} | {} | {:?}",
            ip, port, banner, evidence
        ));
        PortScanResult::open(ip.to_string(), port, banner, evidence)
    } else {
        // æ— ç›´æ¥bannerï¼Œå°è¯•åè®®æ¢æµ‹
        let is_open = probe_specific_protocols(ip, port, &mut banner, &mut evidence).await;

        if is_open {
            if banner.trim().is_empty() {
                banner = "æœåŠ¡æœªçŸ¥".to_string();
            }
            progress.println(format!(
                "  âœ… {}:{} | {} | {:?}",
                ip, port, banner, evidence
            ));
            PortScanResult::open(ip.to_string(), port, banner, evidence)
        } else {
            PortScanResult::closed(ip.to_string(), port)
        }
    }
}
